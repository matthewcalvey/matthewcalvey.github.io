<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>STACKSHOT</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; height: 100%;
      overflow: hidden;
      background: #070a10;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });

  let W = 0, H = 0, DPR = 1;

  function resize() {
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  // ---------- Game parameters ----------
  const BASE = {
    blockH: 26,
    startW: 220,
    minW: 22,
    speed0: 260,     // px/s
    speedRamp: 12,   // per placed block
    camLerp: 0.10,
    floorPad: 90,    // safe bottom for home indicator
  };

  // ---------- State ----------
  const S = {
    started: false,
    dead: false,
    score: 0,
    best: Number(localStorage.getItem("stackshot_best") || 0),
    shake: 0,
    t: 0,
    // camera
    camY: 0,
    // current moving block
    mover: null,
    dir: 1
  };

  let stack = [];

  function reset(runStarts=false) {
    S.started = runStarts;
    S.dead = false;
    S.score = 0;
    S.shake = 0;
    S.t = 0;
    S.dir = 1;
    stack = [];

    // Base block centered
    const baseY = H - BASE.floorPad - BASE.blockH;
    const base = {
      x: (W - BASE.startW) / 2,
      y: baseY,
      w: BASE.startW,
      h: BASE.blockH,
      hue: 200
    };
    stack.push(base);

    S.camY = 0;

    spawnMover();
  }

  function spawnMover() {
    const top = stack[stack.length - 1];
    const nextY = top.y - BASE.blockH;

    // Start from left offscreen
    const w = top.w;
    S.mover = {
      x: -w,
      y: nextY,
      w,
      h: BASE.blockH,
      v: BASE.speed0 + S.score * BASE.speedRamp,
      hue: (top.hue + 28) % 360
    };
  }

  // ---------- Input ----------
  function onTap(e) {
    if (e && e.preventDefault) e.preventDefault();

    if (!S.started) { reset(true); return; }
    if (S.dead) { reset(true); return; }

    placeBlock();
  }

  canvas.addEventListener("pointerdown", onTap, { passive: false });
  canvas.addEventListener("touchstart", onTap, { passive: false });
  canvas.addEventListener("mousedown", onTap, { passive: false });

  document.addEventListener("touchmove", (e) => {
    if (S.started) e.preventDefault();
  }, { passive: false });

  // ---------- Mechanics ----------
  function placeBlock() {
    const m = S.mover;
    const top = stack[stack.length - 1];

    // Overlap interval in x
    const left = Math.max(m.x, top.x);
    const right = Math.min(m.x + m.w, top.x + top.w);
    const overlap = right - left;

    if (overlap <= 0) {
      die();
      return;
    }

    // Perfect bonus: nearly aligned
    const misalign = Math.abs((m.x + m.w/2) - (top.x + top.w/2));
    const perfect = misalign < 6;

    // Create placed block trimmed to overlap
    const placed = {
      x: left,
      y: m.y,
      w: overlap,
      h: m.h,
      hue: m.hue
    };
    stack.push(placed);

    // Falling offcut (visual feedback)
    const offW = m.w - overlap;
    if (offW > 0) {
      const offLeft = (m.x < top.x);
      spawnFaller({
        x: offLeft ? m.x : right,
        y: m.y,
        w: offW,
        h: m.h,
        hue: m.hue,
        vx: offLeft ? -120 : 120
      });
    } else if (perfect) {
      // Small “juice” on perfect
      S.shake = Math.max(S.shake, 6);
      // Keep width (no trim), but snap to top for satisfaction
      placed.x = top.x;
      placed.w = top.w;
    }

    S.score++;
    if (S.score > S.best) {
      S.best = S.score;
      localStorage.setItem("stackshot_best", String(S.best));
    }

    // Too small -> end soon (forces tension)
    if (placed.w < BASE.minW) {
      die();
      return;
    }

    spawnMover();
  }

  function die() {
    S.dead = true;
    S.shake = 12;
  }

  // ---------- Falling pieces ----------
  let fallers = [];
  function spawnFaller(f) {
    fallers.push({
      ...f,
      vy: -120,
      g: 1600,
      life: 2.2
    });
  }

  // ---------- Loop ----------
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    S.t += dt;
    S.shake *= 0.86;
    if (S.shake < 0.2) S.shake = 0;

    if (!S.started) return;

    // Camera follows top of stack
    const top = stack[stack.length - 1];
    const targetCam = Math.max(0, (H * 0.58) - top.y);
    S.camY = lerp(S.camY, targetCam, BASE.camLerp);

    if (!S.dead && S.mover) {
      const m = S.mover;
      m.x += S.dir * m.v * dt;

      // Bounce between margins
      const margin = 10;
      if (m.x + m.w > W - margin) { m.x = W - margin - m.w; S.dir = -1; }
      if (m.x < margin) { m.x = margin; S.dir = 1; }
    }

    // Update fallers
    for (const f of fallers) {
      f.life -= dt;
      f.vy += f.g * dt;
      f.x += f.vx * dt;
      f.y += f.vy * dt;
      f.vx *= (1 - 0.8 * dt);
    }
    fallers = fallers.filter(f => f.life > 0 && f.y < H + 200);
  }

  // ---------- Render ----------
  function render() {
    ctx.clearRect(0, 0, W, H);

    const sx = (Math.random() - 0.5) * S.shake;
    const sy = (Math.random() - 0.5) * S.shake;

    ctx.save();
    ctx.translate(sx, sy);

    // Background gradient
    const bg = ctx.createLinearGradient(0, 0, 0, H);
    bg.addColorStop(0, "#070a10");
    bg.addColorStop(1, "#0c1630");
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, H);

    // Stars
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#fff";
    for (let i = 0; i < 70; i++) {
      const x = (i * 211 + 97) % W;
      const y = (i * 337) % (H * 0.75);
      const tw = 0.6 + 0.5 * Math.sin(S.t * 0.9 + i);
      ctx.globalAlpha = 0.08 + 0.18 * tw;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // World transform for camera
    ctx.save();
    ctx.translate(0, S.camY);

    // Floor glow
    const floorY = H - BASE.floorPad;
    const g = ctx.createLinearGradient(0, floorY - 90, 0, floorY + 120);
    g.addColorStop(0, "rgba(120,200,255,0)");
    g.addColorStop(1, "rgba(120,200,255,0.08)");
    ctx.fillStyle = g;
    ctx.fillRect(0, floorY - 90, W, 220);

    // Stack blocks
    for (const b of stack) {
      drawBlock(b.x, b.y, b.w, b.h, b.hue, 0.95);
    }

    // Falling offcuts
    ctx.globalAlpha = 0.9;
    for (const f of fallers) {
      drawBlock(f.x, f.y, f.w, f.h, f.hue, 0.7);
    }
    ctx.globalAlpha = 1;

    // Mover
    if (S.mover) {
      const m = S.mover;
      drawBlock(m.x, m.y, m.w, m.h, m.hue, S.dead ? 0.4 : 1.0);

      // Shadow hint on top block (makes timing easier)
      const top = stack[stack.length - 1];
      ctx.globalAlpha = 0.2;
      ctx.fillStyle = "#000";
      ctx.fillRect(m.x, top.y + top.h + 8, m.w, 6);
      ctx.globalAlpha = 1;
    }

    ctx.restore(); // end camera

    // HUD
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "800 18px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textBaseline = "top";
    ctx.fillText(`Score: ${S.score}`, 16, 14);
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.fillText(`Best: ${S.best}`, 16, 38);

    // Overlay
    if (!S.started) {
      overlay("STACKSHOT", "Tap to drop blocks.", "Land it. Overhang gets cut. Miss = game over.");
    } else if (S.dead) {
      overlay("GAME OVER", "Tap to restart.", S.score === S.best ? "New best." : `Best: ${S.best}`);
    }

    ctx.restore();

    // Bottom fade for safe area
    safeBottomFade();
  }

  function drawBlock(x, y, w, h, hue, alpha) {
    // Main body
    ctx.globalAlpha = alpha;
    ctx.fillStyle = `hsla(${hue}, 90%, 58%, 0.95)`;
    roundRect(x, y, w, h, 10);

    // Highlight strip
    ctx.globalAlpha = alpha * 0.22;
    ctx.fillStyle = "#fff";
    roundRect(x + 6, y + 6, Math.max(6, w - 12), Math.max(6, h * 0.28), 8);

    // Subtle glow
    ctx.globalAlpha = alpha * 0.22;
    ctx.globalCompositeOperation = "lighter";
    const gx = x + w / 2;
    const gy = y + h / 2;
    const r = Math.max(w, h) * 0.9;
    const grd = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
    grd.addColorStop(0, `hsla(${hue}, 95%, 65%, 0.25)`);
    grd.addColorStop(1, `hsla(${hue}, 95%, 65%, 0)`);
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.ellipse(gx, gy, w * 0.9, h * 2.2, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 1;
  }

  function overlay(title, line1, line2) {
    const bw = Math.min(520, W - 44);
    const bh = 170;
    const bx = (W - bw) / 2;
    const by = (H - bh) / 2;

    ctx.fillStyle = "rgba(0,0,0,0.56)";
    roundRect(bx, by, bw, bh, 18);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "rgba(255,255,255,0.96)";
    ctx.font = "900 30px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, W / 2, by + 50);

    ctx.fillStyle = "rgba(255,255,255,0.82)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(line1, W / 2, by + 96);

    ctx.fillStyle = "rgba(255,255,255,0.70)";
    ctx.font = "500 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(line2, W / 2, by + 124);

    ctx.textAlign = "start";
  }

  function safeBottomFade() {
    ctx.save();
    const y0 = H - BASE.floorPad - 30;
    const g = ctx.createLinearGradient(0, y0, 0, H);
    g.addColorStop(0, "rgba(7,10,16,0)");
    g.addColorStop(1, "rgba(7,10,16,1)");
    ctx.fillStyle = g;
    ctx.fillRect(0, y0, W, H - y0);
    ctx.restore();
  }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
    ctx.fill();
  }

  // Boot
  reset(false);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
