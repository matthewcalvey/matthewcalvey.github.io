<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Aurora Bloom</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; height: 100%;
      background: #05070c;
      overflow: hidden;
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  // ============================================================
  // Aurora Bloom — tap-only timing game for mobile web
  // Designed for: fast feedback, mastery, near-miss tension, high juice
  // ============================================================

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // --- DPI scaling (draw in CSS pixels) ---
  let W = 0, H = 0, DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener("resize", resize, { passive: true });
  resize();

  // --- Helpers ---
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a, b) => a + Math.random() * (b - a);
  const randi = (a, b) => Math.floor(a + Math.random() * (b - a + 1));
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  // --- Safe area padding for iPhone home indicator ---
  const SAFE_BOTTOM = 74;

  // ============================================================
  // Game State
  // ============================================================
  const S = {
    started: false,
    dead: false,
    t: 0,
    dt: 0,
    score: 0,
    best: Number(localStorage.getItem("aurorabloom_best") || 0),
    combo: 0,
    comboMax: 0,
    focus: 1.0,              // 0..1 (health)
    tier: 1,                 // bloom tier based on score pace
    shake: 0,
    pulse: 0,                // global pulse for visuals
    // Difficulty ramps:
    speed: 0.85,             // controls seed travel time
    density: 0.85,           // spawn rate multiplier
    ringR: 112,
    ringW: 10,
    // Timing windows (px distance to ring)
    perfectWin: 9,
    goodWin: 18,
    okWin: 28,
  };

  const center = () => ({ x: W / 2, y: H * 0.46 });

  // Seeds approach the ring from outside; you tap when a seed crosses ring radius.
  let seeds = [];
  let blooms = [];
  let particles = [];
  let wisps = [];

  // “Beat” cadence (for feel); not audio, but used for subtle pulses.
  let bpm = 108; // base; will ramp
  let beatPhase = 0;

  function reset(runStarts) {
    S.started = runStarts;
    S.dead = false;
    S.t = 0;
    S.score = 0;
    S.combo = 0;
    S.comboMax = 0;
    S.focus = 1.0;
    S.tier = 1;
    S.shake = 0;
    S.pulse = 0;

    S.speed = 0.85;
    S.density = 0.85;
    bpm = 108;
    beatPhase = 0;

    seeds = [];
    blooms = [];
    particles = [];
    wisps = [];

    // Create background wisps (aesthetic layer)
    for (let i = 0; i < 24; i++) {
      wisps.push(makeWisp());
    }
  }

  function makeWisp() {
    const c = center();
    const ang = rand(0, Math.PI * 2);
    return {
      baseAng: ang,
      r: rand(120, Math.min(W, H) * 0.55),
      w: rand(26, 80),
      a: rand(0.06, 0.16),
      drift: rand(0.08, 0.22) * (Math.random() < 0.5 ? -1 : 1),
      hue: rand(180, 310),
      phase: rand(0, Math.PI * 2),
      cx: c.x, cy: c.y
    };
  }

  function spawnSeed() {
    const c = center();
    const ringR = S.ringR;
    // start radius outside ring and drift inward to ring and beyond
    const startR = Math.min(W, H) * rand(0.62, 0.9);
    const ang = rand(0, Math.PI * 2);

    // travel time shorter as speed increases
    const travel = lerp(1.35, 0.72, clamp((S.speed - 0.85) / 1.4, 0, 1));

    // Each seed has its own hue; gorgeous palette
    const hue = (rand(170, 320) + S.combo * 3) % 360;

    seeds.push({
      ang,
      r: startR,
      startR,
      // target is center cross; ring is where you tap
      travel,
      age: 0,
      alive: true,
      hue,
      size: rand(4.5, 7.5),
      wobble: rand(0.7, 1.7),
      wobbleP: rand(0, Math.PI * 2),
      // for scoring
      scored: false
    });
  }

  function spawnBloom(x, y, hue, strength) {
    blooms.push({
      x, y,
      hue,
      age: 0,
      life: lerp(0.55, 1.0, strength),
      strength
    });

    // Particle burst
    const count = Math.floor(24 + 46 * strength);
    for (let i = 0; i < count; i++) {
      const a = rand(0, Math.PI * 2);
      const sp = rand(60, 520) * lerp(0.35, 1.0, strength);
      particles.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        age: 0,
        life: rand(0.35, 1.0),
        hue: (hue + rand(-18, 18) + 360) % 360,
        s: rand(1.2, 3.2),
        drag: rand(2.2, 5.4)
      });
    }
  }

  // ============================================================
  // Input (tap only)
  // ============================================================
  function onTap(e) {
    if (e && e.preventDefault) e.preventDefault();

    if (!S.started) { reset(true); return; }
    if (S.dead) { reset(true); return; }

    // On tap: evaluate closest seed to ring crossing (best candidate).
    const c = center();
    const ringR = S.ringR;

    // Find seed with minimal |distance to ring|
    let best = null;
    let bestD = Infinity;

    for (const s of seeds) {
      if (!s.alive) continue;
      const d = Math.abs(s.r - ringR);
      if (d < bestD) { bestD = d; best = s; }
    }

    // If no seed: small penalty (teaches pacing)
    if (!best) { miss("empty"); return; }

    // Determine accuracy by distance from ring radius
    const d = bestD;

    // windows in pixels
    const p = S.perfectWin;
    const g = S.goodWin;
    const o = S.okWin;

    if (d <= p) {
      hit(best, "perfect", 1.0);
    } else if (d <= g) {
      hit(best, "good", 0.7);
    } else if (d <= o) {
      hit(best, "ok", 0.45);
    } else {
      miss("late/early");
    }
  }

  canvas.addEventListener("pointerdown", onTap, { passive: false });
  canvas.addEventListener("touchstart", onTap, { passive: false });
  canvas.addEventListener("mousedown", onTap, { passive: false });

  // Block scroll/rubber band while playing
  document.addEventListener("touchmove", (e) => {
    if (S.started) e.preventDefault();
  }, { passive: false });

  // ============================================================
  // Scoring / Feedback
  // ============================================================
  function miss(type) {
    // Miss drains focus and resets combo
    S.combo = 0;
    S.focus -= 0.09;
    S.shake = Math.max(S.shake, 7);

    // Create a dull “thud” particle at ring
    const c = center();
    spawnBloom(c.x, c.y, 0, 0.18);

    if (S.focus <= 0) die();
  }

  function hit(seed, grade, strength) {
    // Consume seed
    seed.alive = false;

    // Combo and focus regen
    S.combo += (grade === "perfect" ? 2 : 1);
    S.comboMax = Math.max(S.comboMax, S.combo);

    // Focus: reward accuracy and streaks
    S.focus += 0.04 * strength + clamp(S.combo * 0.0009, 0, 0.028);
    S.focus = clamp(S.focus, 0, 1);

    // Score: base + combo multiplier
    const base = grade === "perfect" ? 120 : grade === "good" ? 78 : 42;
    const mult = 1 + Math.min(2.2, S.combo * 0.06);
    S.score += Math.floor(base * mult);

    // Visual feedback: bloom at seed position
    const c = center();
    const x = c.x + Math.cos(seed.ang) * seed.r;
    const y = c.y + Math.sin(seed.ang) * seed.r;
    spawnBloom(x, y, seed.hue, strength);

    // Subtle screen shake for perfects
    if (grade === "perfect") S.shake = Math.max(S.shake, 5);

    // Pulse on hits for aesthetic rhythm
    S.pulse = Math.max(S.pulse, 0.85 * strength);
  }

  function die() {
    S.dead = true;
    S.shake = 12;
    if (S.score > S.best) {
      S.best = S.score;
      localStorage.setItem("aurorabloom_best", String(S.best));
    }
  }

  // ============================================================
  // Main Loop
  // ============================================================
  let last = performance.now();
  function frame(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    S.dt = dt;

    update(dt);
    draw();

    requestAnimationFrame(frame);
  }

  function update(dt) {
    // Always decay shake and pulse
    S.shake *= 0.88;
    if (S.shake < 0.2) S.shake = 0;

    S.pulse = Math.max(0, S.pulse - dt * 1.7);

    if (!S.started || S.dead) {
      // idle animation timing
      S.t += dt;
      beatPhase += dt * (bpm / 60) * Math.PI * 2;
      return;
    }

    S.t += dt;

    // Difficulty ramp (gentle but meaningful)
    // speed affects how fast seeds move inward; density affects spawn rate.
    const m = Math.min(1, S.t / 70);
    S.speed = 0.85 + 1.55 * easeOutCubic(m);
    S.density = 0.85 + 1.25 * easeOutCubic(m);
    bpm = 108 + 34 * easeOutCubic(m);

    // Tier (a light meta goal): changes palette intensity and ring glow
    const newTier = 1 + Math.floor(S.score / 8000);
    S.tier = clamp(newTier, 1, 8);

    // Beat phase for pulsing visuals
    beatPhase += dt * (bpm / 60) * Math.PI * 2;

    // Spawn control: aim for a steady stream; scale with density.
    // Micro-loop: constant “incoming opportunities” every ~0.5–0.9 seconds.
    const targetRate = lerp(1.15, 2.2, clamp((S.density - 0.85) / 1.25, 0, 1)); // seeds/sec
    // Add slight rhythmic modulation to feel musical
    const rhythm = 0.75 + 0.25 * Math.sin(beatPhase);
    const rate = targetRate * rhythm;

    // Poisson-ish spawning
    const spawnProb = rate * dt;
    if (Math.random() < spawnProb) spawnSeed();

    // Update seeds
    const ringR = S.ringR;
    for (const s of seeds) {
      if (!s.alive) continue;
      s.age += dt;

      // Progress 0..1 over travel time
      const u = clamp(s.age / s.travel, 0, 1);

      // Inward motion to center (r -> 0), with a slight wobble for life
      const wob = Math.sin(s.wobbleP + S.t * (2.2 * s.wobble)) * 6.5;
      s.r = lerp(s.startR, 0, easeOutCubic(u)) + wob;

      // If it passed too far beyond center without being tapped -> miss event
      if (u >= 1 && s.alive) {
        s.alive = false;
        // A missed seed: mild punishment; encourages attention
        S.focus -= 0.055;
        S.combo = 0;
        if (S.focus <= 0) die();
      }
    }

    // Clean old seeds
    seeds = seeds.filter(s => (s.alive || s.age < s.travel + 0.25));

    // Update blooms
    for (const b of blooms) b.age += dt;
    blooms = blooms.filter(b => b.age < b.life);

    // Update particles
    for (const p of particles) {
      p.age += dt;
      // simple drag
      p.vx -= p.vx * p.drag * dt;
      p.vy -= p.vy * p.drag * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
    }
    particles = particles.filter(p => p.age < p.life);

    // Wisps drift
    const c = center();
    for (const w of wisps) {
      w.phase += dt * w.drift;
      w.cx = c.x;
      w.cy = c.y;
    }
  }

  // ============================================================
  // Rendering
  // ============================================================
  function draw() {
    // background with subtle gradient + aurora wisps
    ctx.clearRect(0, 0, W, H);

    const sx = (Math.random() - 0.5) * S.shake;
    const sy = (Math.random() - 0.5) * S.shake;

    ctx.save();
    ctx.translate(sx, sy);

    // Base gradient
    const bg = ctx.createLinearGradient(0, 0, 0, H);
    bg.addColorStop(0, "#05070c");
    bg.addColorStop(1, "#081422");
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, H);

    // Star dust (lightweight)
    drawStars();

    // Aurora wisps
    drawWisps();

    // Ring + glow
    drawRing();

    // Seeds
    drawSeeds();

    // Blooms
    drawBlooms();

    // Particles
    drawParticles();

    // HUD
    drawHUD();

    // Overlay states
    if (!S.started) {
      overlay("AURORA BLOOM", "Tap to start. Tap when seeds cross the ring.", "Perfect hits build combo and restore focus.");
    } else if (S.dead) {
      overlay("Bloom Faded", "Tap to restart.", S.score === S.best ? "New best." : `Best: ${S.best}`);
    }

    ctx.restore();

    // Bottom safe area fade
    safeAreaShade();
  }

  // --- Background accents ---
  function drawStars() {
    // Use deterministic-ish pseudo scatter based on time; cheap and pretty.
    const n = 80;
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#ffffff";
    for (let i = 0; i < n; i++) {
      const x = (i * 193 + 97) % W;
      const y = ((i * 331) % (H * 0.75));
      const tw = 0.6 + 0.7 * (0.5 + 0.5 * Math.sin(S.t * 0.9 + i));
      ctx.globalAlpha = 0.08 + 0.18 * tw;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  function drawWisps() {
    const c = center();
    ctx.globalCompositeOperation = "lighter";

    for (const w of wisps) {
      const a = w.baseAng + 0.35 * Math.sin(w.phase);
      const rx = Math.cos(a) * w.r;
      const ry = Math.sin(a) * w.r * 0.72;

      const x = c.x + rx;
      const y = c.y + ry;

      const grd = ctx.createRadialGradient(x, y, 0, x, y, w.w);
      const hue = (w.hue + S.tier * 6) % 360;
      grd.addColorStop(0, `hsla(${hue}, 90%, 60%, ${w.a})`);
      grd.addColorStop(1, `hsla(${hue}, 90%, 60%, 0)`);

      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.ellipse(x, y, w.w * 1.25, w.w * 0.8, a, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.globalCompositeOperation = "source-over";
  }

  // --- Core visuals ---
  function drawRing() {
    const c = center();
    const r = S.ringR;
    const w = S.ringW;

    // Outer glow intensifies with tier, pulse, and focus
    const glow = 0.18 + 0.07 * S.tier + 0.22 * S.pulse + 0.12 * (1 - S.focus);
    const hue = (210 + S.tier * 12) % 360;

    ctx.globalCompositeOperation = "lighter";
    const g = ctx.createRadialGradient(c.x, c.y, r - 24, c.x, c.y, r + 46);
    g.addColorStop(0, `hsla(${hue}, 95%, 62%, 0)`);
    g.addColorStop(0.45, `hsla(${hue}, 95%, 62%, ${glow})`);
    g.addColorStop(1, `hsla(${hue}, 95%, 62%, 0)`);

    ctx.strokeStyle = g;
    ctx.lineWidth = w + 10;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    ctx.stroke();

    // Ring body
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = `rgba(255,255,255,0.65)`;
    ctx.lineWidth = w;
    ctx.beginPath();
    ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
    ctx.stroke();

    // Beat tick marks (subtle rhythm cue)
    const ticks = 10;
    const beat = 0.5 + 0.5 * Math.sin(beatPhase);
    ctx.globalAlpha = 0.14 + 0.18 * beat;
    ctx.strokeStyle = `hsla(${hue}, 90%, 70%, 1)`;
    ctx.lineWidth = 2;
    for (let i = 0; i < ticks; i++) {
      const a = (i / ticks) * Math.PI * 2 + 0.2 * Math.sin(S.t * 0.7);
      const x1 = c.x + Math.cos(a) * (r - 14);
      const y1 = c.y + Math.sin(a) * (r - 14);
      const x2 = c.x + Math.cos(a) * (r - 2);
      const y2 = c.y + Math.sin(a) * (r - 2);
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawSeeds() {
    const c = center();
    ctx.globalCompositeOperation = "lighter";

    for (const s of seeds) {
      if (!s.alive) continue;

      const x = c.x + Math.cos(s.ang) * s.r;
      const y = c.y + Math.sin(s.ang) * s.r;

      // Make seeds brighter near ring to guide attention (learnability)
      const d = Math.abs(s.r - S.ringR);
      const attn = 1 - clamp(d / 90, 0, 1);

      const glow = ctx.createRadialGradient(x, y, 0, x, y, 24);
      glow.addColorStop(0, `hsla(${s.hue}, 100%, 70%, ${0.22 + 0.35 * attn})`);
      glow.addColorStop(1, `hsla(${s.hue}, 100%, 70%, 0)`);

      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(x, y, 18, 0, Math.PI * 2);
      ctx.fill();

      // Core
      ctx.fillStyle = `hsla(${s.hue}, 95%, ${60 + 16 * attn}%, 0.9)`;
      ctx.beginPath();
      ctx.arc(x, y, s.size, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.globalCompositeOperation = "source-over";
  }

  function drawBlooms() {
    ctx.globalCompositeOperation = "lighter";
    for (const b of blooms) {
      const u = clamp(b.age / b.life, 0, 1);
      const k = 1 - u;
      const r = lerp(18, 140, easeOutCubic(u)) * lerp(0.55, 1.15, b.strength);

      const grd = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, r);
      grd.addColorStop(0, `hsla(${b.hue}, 100%, 70%, ${0.36 * k})`);
      grd.addColorStop(0.55, `hsla(${b.hue}, 95%, 60%, ${0.18 * k})`);
      grd.addColorStop(1, `hsla(${b.hue}, 95%, 60%, 0)`);

      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(b.x, b.y, r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalCompositeOperation = "source-over";
  }

  function drawParticles() {
    ctx.globalCompositeOperation = "lighter";
    for (const p of particles) {
      const u = clamp(p.age / p.life, 0, 1);
      const k = 1 - u;
      ctx.globalAlpha = 0.85 * k;
      ctx.fillStyle = `hsla(${p.hue}, 95%, 70%, 1)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.s * (0.7 + 0.6 * k), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
  }

  function drawHUD() {
    // Top-left stats
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.textBaseline = "top";

    ctx.font = "800 18px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(`Score  ${S.score}`, 16, 14);

    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.fillText(`Best  ${S.best}`, 16, 38);
    ctx.fillText(`Combo  ${S.combo}`, 16, 56);
    ctx.fillText(`Tier  ${S.tier}`, 16, 74);

    // Focus bar (top-right)
    const barW = Math.min(190, W * 0.34);
    const barH = 12;
    const x = W - barW - 16;
    const y = 18;

    // Outline
    ctx.fillStyle = "rgba(255,255,255,0.16)";
    roundRect(x, y, barW, barH, 6, true);

    // Fill with hue shift by tier
    const hue = (140 + S.tier * 16) % 360;
    const fw = Math.max(0, barW * clamp(S.focus, 0, 1));

    // “danger glow” at low focus
    const danger = clamp((0.35 - S.focus) / 0.35, 0, 1);
    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = 0.25 + 0.35 * (1 - danger);
    ctx.fillStyle = `hsla(${hue}, 95%, 62%, 1)`;
    roundRect(x, y, fw, barH, 6, true);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";

    // Low focus warning shimmer
    if (S.started && !S.dead && danger > 0) {
      ctx.globalAlpha = 0.18 + 0.22 * danger * (0.5 + 0.5 * Math.sin(S.t * 10));
      ctx.fillStyle = "rgba(255,80,80,1)";
      ctx.fillText("FOCUS LOW", x, y + 18);
      ctx.globalAlpha = 1;
    }
  }

  function overlay(title, line1, line2) {
    const bw = Math.min(480, W - 44);
    const bh = 170;
    const bx = (W - bw) / 2;
    const by = (H - bh) / 2;

    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = "rgba(0,0,0,0.56)";
    roundRect(bx, by, bw, bh, 18, true);

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.fillStyle = "rgba(255,255,255,0.96)";
    ctx.font = "900 28px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(title, W / 2, by + 48);

    ctx.fillStyle = "rgba(255,255,255,0.82)";
    ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(line1, W / 2, by + 92);

    ctx.fillStyle = "rgba(255,255,255,0.70)";
    ctx.font = "500 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.fillText(line2, W / 2, by + 122);

    ctx.textAlign = "start";
  }

  function safeAreaShade() {
    // Slight shade at bottom to reduce accidental attention to home indicator region
    ctx.save();
    ctx.globalAlpha = 0.55;
    const g = ctx.createLinearGradient(0, H - SAFE_BOTTOM - 30, 0, H);
    g.addColorStop(0, "rgba(5,7,12,0)");
    g.addColorStop(1, "rgba(5,7,12,1)");
    ctx.fillStyle = g;
    ctx.fillRect(0, H - SAFE_BOTTOM - 30, W, SAFE_BOTTOM + 30);
    ctx.restore();
  }

  function roundRect(x, y, w, h, r, fill) {
    const rr = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + rr, y);
    ctx.arcTo(x + w, y, x + w, y + h, rr);
    ctx.arcTo(x + w, y + h, x, y + h, rr);
    ctx.arcTo(x, y + h, x, y, rr);
    ctx.arcTo(x, y, x + w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  // ============================================================
  // Boot
  // ============================================================
  reset(false);
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
